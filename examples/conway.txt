[ this is a limited rendition of Conway's Game of Life, implemented purely in ash-script ]
[ since Conway's Game of Life is Turing-complete, the existence of this functioning program proves that ash-script as a programming language is also Turing-complete ]
[ however, since the interpreter for this language is very unoptimised, the simulation is also very slow ]

let settings {
	let world {
		let width 60;
		let height 25;
	};

	[ this property defines the initial state of the game, which the simulation will mutate as generations pass ]
	[ any character that is not a space is counted as a live cell, with all other cells being counted as dead ]
	let initialState {
		let 0	"                                                            ";
		let 1	"                                                            ";
		let 2	"                                                            ";
		let 3	"                                                            ";
		let 4	"                                                            ";
		let 5	"                                                            ";
		let 6	"                                                            ";
		let 7	"                                                            ";
		let 8	"                                                            ";
		let 9	"                                                            ";
		let 10	"                                                            ";
		let 11 	"                     @                                      ";
		let 12	"                       @                                    ";
		let 13	"                    @@  @@@                                 ";
		let 14	"                                                            ";
		let 15	"                                                            ";
		let 16	"                                                            ";
		let 17	"                                                            ";
		let 18	"                                                            ";
		let 19	"                                                            ";
		let 20	"                                                            ";
		let 21	"                                                            ";
		let 22	"                                                            ";
		let 23	"                                                            ";
		let 24	"                                                            ";
	};
};

let world {};

[ iterate through each cell in the world and set its state based on the settings.initialState property ]
do {
	let y 0;

	while (y < settings.world.height) {
		mut world y {};

		let x 0;

		while (x < settings.world.width) {
			[ the string slicing operator is used here to select the character, from the string at row y, associated with the current x value ]
			mut (world y) x (settings.initialState y </ (x + 1) >/ x != " ");

			set x (x + 1);
		};

		set y (y + 1);
	};
};

let go 1;

[ continuously print the current state of the game, ask the user for their verdict, then update the state ]
while go {
	let newWorld {};

	print "\x1Bc";

	let y 0;

	[ iterate through each cell and print it in a grid ]
	while (y < settings.world.height) {
		let x 0;

		while (x < settings.world.width) {
			[ an '@' represents an alive cell and a ' ' represents a dead cell ]
			if (world y x) {
				print "@";
			} {
				print " ";
			};

			set x (x + 1);
		};

		[ print a border at the rightmost edge of the map ]
		print "|\n";

		set y (y + 1);
	};

	let x 0;

	[ print a border at the bottom edge of the map ]
	while (x < settings.world.width) {
		print "-";
		set x (x + 1);
	};

	[ ask the user for the desired action ]
	print "#\n\nTo step the simulation, press Enter. To exit, type any character and press Enter.\n";
	set go ({input x; return x;} == "");

	if go {
		print "Processing... ";
	};

	set y 0;

	[
		Iterate through each cell in the world and set its new state according to the following set of conditions:
		1. Any live cell with fewer than two live neighbours dies, as if by underpopulation.
		2. Any live cell with two or three live neighbours lives on to the next generation.
		3. Any live cell with more than three live neighbours dies, as if by overpopulation.
		4. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

		Condition specification sourced from <https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life>.
	]
	while (go && y < settings.world.height) {
		let x 0;

		mut newWorld y {};

		while (x < settings.world.width) {
			let total 0;

			[ update the total number of alive neighbors based on whether each neighboring cell is alive or dead ]
			let total (total + (world (y - 1) (x - 1) || 0));
			let total (total + (world (y - 1) x || 0));
			let total (total + (world (y - 1) (x + 1) || 0));
			let total (total + (world y (x - 1) || 0));
			let total (total + (world y (x + 1) || 0));
			let total (total + (world (y + 1) (x - 1) || 0));
			let total (total + (world (y + 1) x || 0));
			let total (total + (world (y + 1) (x + 1) || 0));

			[ if the current cell is alive, kill it unless it has 2 or 3 neighbors ]
			[ otherwise, revive the cell if it has exactly 3 neighbors ]
			if (world y x) {
				mut (newWorld y) x (total > 1 && total < 4);
			} {
				mut (newWorld y) x (total == 3);
			};

			set x (x + 1);
		};

		set y (y + 1);
	};

	[ set the current state of the world to the new state ]
	set world newWorld;
};
